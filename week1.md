# 🤖 1주차 릴레이 프로젝트

### 목차

- [사회자봇]
- [캠프토닥이]
- [🌸 포에틱 캠프: 일상 속 시적 휴식]
- [부캠네컷]

# **힐링 AI를 만들어보자!**

## **사회자봇**

- **배경:**
  부스트캠프에서 매주 줌으로 진행되는 팀 미팅은 처음 보는 사람들과의 어색함으로 인해 대화가 딱딱해지기 쉽다. 따라서 회의 시작 전 어색한 침묵을 깨기 위해 가벼운 대화를 시작할 수 있도록 주제를 제안해주는 기능이 필요하다.
- **목적:**
  상황에 맞는 스몰토크 예시를 제공하여 분위기를 자연스럽게 유도할 수 있도록 돕는 기능을 개발한다.
- **달성 기준:**
  1. 요일, 시간대, 계절 등 맥락에 따라 스몰토크 주제를 추천할 수 있다.
  2. 사회자봇이 순서를 정해주고, 간단한 자기소개 템플릿을 제공하면 이를 통해 자기소개 시간을 갖는다!
  3. 사용자가 직접 프롬프트를 수정해보며 봇의 응답을 커스터마이징한다.

예시) https://chatgpt.com/g/g-6879df9f43688191949682824388c77b-pieopideubaeg-jinhaengja

---

## **캠프토닥이**

- **배경:**
  부스트캠프는 매일 몰입하며 성장하는 프로그램이지만 장기적으로 지치거나 심리적인 거리감을 느낄 수 있다. 때로는 온라인으로만 만나게 되는 캠퍼들에게는 사소한 응원의 한마디가 큰 힘이 되기도 한다. 매일 같은 시간, 격려 메시지를 자동으로 보내주는 봇이 있다면 전체적인 분위기와 에너지를 유지하는데 도움이 되지 않을까?
- **목적:**
  모든 캠퍼들이 매일 긍정적인 마음으로 하루를 시작하거나 마무리할 수 있도록 돕는다.

- 달성 기준:
  1. 매일 정해진 시간(오후 2시, 오후 6시 등)에 메시지를 전송한다.
  2. 메시지는 격려, 공감, 칭찬 등을 포함한 문구로 자동화해본다.
  3. 요일/시간대/캠프 진행 기간에 맞춘 맞춤형 메시지를 보낸다.
  4. 댓글을 5개 이상 받는다.
  5. 🔥 하루 응답 수 또는 리액션 수를 로그로 기록해서 어느 메시지가 반응이 좋았는지 파악하여 업데이트를 진행해 본다.
  6. 🔥 매일 정해진 시간(오후 2시, 오후 6시 등)에 **자동화**하여 메시지를 전송한다.

---

## 🌸 포에틱 캠프: 일상 속 시적 휴식

매일 반복되는 코딩 미션으로 지친 캠퍼들을 위한 **감성 회복 프로그램**입니다.  
AI 시인과 함께하는 하루 10분의 시적 여행으로, 마음의 여유를 되찾고 내일을 위한 에너지를 충전해보세요.

### 🎯 배경 및 목적

**"기술자도 시인이 될 수 있다"**

바쁜 개발 일상 속에서 잃어버린 감성을 되찾고, 동료들과 시를 통해 소통하며,
창의적 사고력을 기르는 **일상 속 시적 루틴**을 만드는 것이 목표입니다.

### 🌟 달성 기준

#### 1단계: 일상의 시적 발견 (매일 아침)

- **나만의 시적 주제 찾기**: 오늘 하루의 감정, 날씨, 또는 마음에 떠오른 단어를 시의 재료로 활용
- **시인 멘토 선택**: 윤동주의 서정성, 하이쿠의 간결함, 힙합의 리듬감 등 오늘의 기분에 맞는 스타일 선택

#### 2단계: AI 시인과의 협업 창작

- **맞춤형 시 생성**: 선택한 주제와 스타일로 AI가 감성적인 시 창작
- **음성으로 듣는 시**: 생성된 시를 음성으로 들으며 몰입감 있는 시적 경험

#### 3단계: 나도 시인이 되어보기

- **창작 도전**: 직접 시를 써보며 내면의 시인 발견
- **AI 멘토링**: 작성한 시에 대한 따뜻한 피드백과 구체적인 조언 받기

#### 4단계: 시적 공동체 형성

- **일일 시 갤러리**: 슬랙 채널에 오늘의 시와 감상 공유
- **시적 소통**: 동료들의 시에 감상평 남기며 서로 격려
- **주간 베스트**: 매주 가장 인상 깊었던 시 선정 및 시상

### 📋 구체적 활동 가이드

**매일 아침 루틴 (10분)**

1. AI에게 오늘의 기분이나 떠오른 단어 전달
2. 시인 스타일 선택 (윤동주, 하이쿠, 자유시, 랩 등)
3. 생성된 시를 음성으로 들으며 감상
4. 영감을 받아 나만의 시 한 편 창작
5. AI 멘토에게 피드백 받기
6. 슬랙에 오늘의 시와 한 줄 감상 공유

**주간 활동**

- 월요일: 새로운 한 주 다짐을 담은 시
- 화요일: 어제의 성취나 실패를 돌아보는 시
- 수요일: 중간점검, 현재 마음 상태를 담은 시
- 목요일: 동료나 친구에게 전하고 싶은 시
- 금요일: 한 주를 마무리하는 감사의 시

### 💡 기대 효과

- **스트레스 해소**: 창작 활동을 통한 심리적 안정감
- **창의적 사고**: 시적 표현을 통한 문제 해결 능력 향상
- **팀워크 강화**: 감성적 소통을 통한 동료 간 유대감 증진
- **자기 표현**: 내면의 감정을 건강하게 표출하는 방법 학습

---

## **부캠네컷**

- **배경:**

  매일 새로운 문제를 풀다보면 체력과 멘탈이 함께 지치기 시작합니다. 이럴 때 잠깐의 웃음이 큰 리프레시가 됩니다. 그래서 준비한 **네 컷 만화 그려보기 퀘스트**입니다!

  거창할 필요 없이, 지금 내 상황을 유쾌하게 그려보며 **소소한 재미와 감정 해소**를 느껴보자는 취지입니다.

- **목적:**
  캠퍼들이 스스로의 상황을 AI에게 말하면서 **가볍게 표현해보고 웃어볼 기회**를 만든다. 여러 스타일로 네컷 만화를 그려보면서 뜨거웠던 머리를 식히며 쉬는 시간을 갖는다.
- **달성 기준:**
  1. 본인의 캠프 상황(지침, 버그, 수면 부족, 팀워크 등)을 소재로 한 4컷 구성을 만든다.
  2. 팀 채널이나 커뮤니티 채널에 공유해본다.
  3. 다른 사람의 만화에 리액션을 1개 이상 남긴다.
  4. 여러 VLM을 사용하며 여러 네컷만화를 생성해 본다.

---

# 퀘스트 수행 결과

## 🌸 포에틱 캠프: 일상 속 시적 휴식

### 🛠️ 구현 아키텍처

#### 1. 클래스 설계: PoeticCamp

```javascript
class PoeticCamp {
  constructor() {
    this.baseDir = path.join(__dirname, "poetic-data");
    this.poemsDir = path.join(this.baseDir, "poems");
    this.audioDir = path.join(this.baseDir, "audio");
    this.profilePath = path.join(this.baseDir, "profile.json");
  }
}
```

**핵심 변화:**

- **데이터 구조화**: 시/음성/프로필을 분리된 디렉토리로 관리
- **사용자 프로필**: 지속적 참여를 위한 개인화 시스템
- **JSON 기반 저장**: 메타데이터와 함께 구조화된 데이터 관리

#### 2. 요일별 테마 시스템

```javascript
getDayTheme();
{
  const themes = {
    월: "새로운 한 주 다짐을 담은 시",
    화: "어제의 성취나 실패를 돌아보는 시",
    수: "중간점검, 현재 마음 상태를 담은 시",
    목: "동료나 친구에게 전하고 싶은 시",
    금: "한 주를 마무리하는 감사의 시",
  };
}
```

**설계 의도:**

- **지속성 확보**: 매일 다른 테마로 참여 동기 부여
- **감정적 여정**: 주간 단위의 감정 흐름 반영
- **자연스러운 루틴**: 요일에 맞는 자연스러운 주제 제시

#### 3. 4단계 아침 루틴 구현

```javascript
async;
morningRoutine();
{
  // 1단계: 일상의 시적 발견
  const mood = readlineSync.question(
    "지금 당신의 기분이나 마음에 떠오른 단어를 자유롭게 말해주세요: "
  );

  // 2단계: AI 시인과의 협업 창작
  const poem = await this.generatePoem(mood, selectedStyle, mood);

  // 3단계: 나도 시인이 되어보기
  if (writeOwn) {
    const userEvaluation = await this.evaluatePoem(userPoem, true);
  }

  // 4단계: 시적 공동체 형성
  console.log(
    "생성된 시와 감상을 슬랙 채널에 공유하여 동료들과 함께 시적 감성을 나누어보세요!"
  );
}
```

#### 4. 음성 기능 구현

```javascript
async;
generateAudio(text, filename);
{
  return new Promise((resolve, reject) => {
    const audioPath = path.join(this.audioDir, `${filename}.mp3`);
    const tts = new gtts(text, "ko");

    tts.save(audioPath, (err) => {
      if (err) reject(new Error(`음성 생성 실패: ${err.message}`));
      else resolve(audioPath);
    });
  });
}
```

**구현 결정:**

- **필수 기능으로 승격**: 몰입감 있는 시적 경험을 위해 필수로 구현
- **Google TTS 활용**: 한국어 지원과 품질을 고려하여 선택
- **파일 저장**: 재생 가능한 mp3 파일로 저장하여 반복 감상 가능

#### 5. 성장 추적 시스템

```javascript
showGrowthStats();
{
  console.log(`📚 총 시 작품 수: ${this.profile.totalPoems}편`);
  console.log(`🔥 주간 연속 참여: ${this.profile.weeklyStreak}일`);

  const consistency = Math.round((this.profile.totalPoems / daysActive) * 100);
  console.log(
    `지속성: ${consistency}% (${this.profile.totalPoems}/${daysActive}일)`
  );
}
```

### 🌟 핵심 설계 철학의 진화

#### 1. 단순한 도구 → 감성 회복 프로그램

**이전**: 시 생성하고 평가받는 단순한 봇
**현재**: 일상의 감성을 회복하고 동료와 소통하는 종합 프로그램

#### 2. 일회성 사용 → 지속적 루틴

**이전**: 필요할 때만 사용하는 도구
**현재**: 매일 아침 10분의 시적 루틴 형성

#### 3. 개별 창작 → 공동체 형성

**이전**: 혼자서 시를 쓰고 평가받는 개별 활동
**현재**: 동료들과 시를 공유하며 유대감을 형성하는 공동체 활동

### 📊 새로운 요구사항 충족도

| 새로운 요구사항 | 구현 방식                             | 완성도  |
| --------------- | ------------------------------------- | ------- |
| 4단계 경험 여정 | `morningRoutine()` 메서드로 통합 구현 | ✅ 100% |
| 요일별 테마     | `getDayTheme()` 자동 인식 시스템      | ✅ 100% |
| 음성 시 감상    | Google TTS 기반 음성 생성             | ✅ 100% |
| 시적 성장 추적  | JSON 기반 프로필 관리                 | ✅ 100% |
| 아침 루틴 모드  | `npm run morning` 전용 명령어         | ✅ 100% |
| 개인화 경험     | 이름, 선호 스타일 등 프로필 시스템    | ✅ 100% |

### 🔍 기술적 도전

#### 1. 음성 생성의 비동기 처리

**도전**: Google TTS의 콜백 기반 API를 Promise로 래핑
**해결**: Promise 기반 async/await 패턴으로 일관된 비동기 처리

#### 2. 복합 데이터 구조 설계

**도전**: 시, 평가, 음성, 메타데이터를 하나의 기록으로 관리
**해결**: JSON 기반 구조화된 데이터 모델로 확장성 확보

#### 3. CLI에서의 몰입감 있는 UX

**도전**: 텍스트 기반 인터페이스에서 감성적 경험 구현
**해결**: 단계별 구분선, 이모지, 진행 상황 표시로 시각적 구조화

### 📅 개선 가능한 내용

- **GUI 개발**: CLI에서 GUI로 전환하여 사용자 경험 향상
- **음성 개선**: gtts 외 다양한 TTS 엔진 비교 및 적용
- **슬랙 통합**: 슬랙 봇을 통해 시 공유 및 피드백 기능 구현

## 부캠 네컷

- Sora를 통해 네컷 만화 이미지 생성
- 프롬프트

```
첫번째 컷: 7월 24일: 퀭하게 코딩하는 모습 (대사 없음)
두번째 컷: 7월 25일: 어느정도 괜찮게 코딩하는 모습 (대사 없음)
세번째 컷: 두번째 컷에서 눈깜빡 (깜빡 텍스트)
네번째 컷: 7월 28일: 주말이 지나가서 황당한 모습 (대사 없음)

모두 일관적으로 책상 앞에 앉아 컴퓨터 하는 모습이며, 날짜 텍스트는 모두 표기
```

- 생성 결과

<img width="1102" height="828" alt="Image" src="https://github.com/user-attachments/assets/a75af263-6ee6-450e-9698-c156d87344cc" />

- Slack에 공유

<img width="855" height="717" alt="Image" src="https://github.com/user-attachments/assets/686eb1e6-d29a-4c0e-ab5a-80f08258b5f6" />

K026

https://www.notion.so/1-23425d524d6b80d3b9c7e4894d925f95

---

## **캠프토닥이** - K026

- **배경:**
  부스트캠프는 매일 몰입하며 성장하는 프로그램이지만 장기적으로 지치거나 심리적인 거리감을 느낄 수 있다. 때로는 온라인으로만 만나게 되는 캠퍼들에게는 사소한 응원의 한마디가 큰 힘이 되기도 한다. 매일 같은 시간, 격려 메시지를 자동으로 보내주는 봇이 있다면 전체적인 분위기와 에너지를 유지하는데 도움이 되지 않을까?
- **목적:** 모든 캠퍼들이 매일 긍정적인 마음으로 하루를 시작하거나 마무리할 수 있도록 돕는다.
- 달성 기준:
  1. 매일 정해진 시간(오후 2시, 오후 6시 등)에 메시지를 전송한다.
  2. 메시지는 격려, 공감, 칭찬 등을 포함한 문구로 자동화해본다.
  3. 요일/시간대/캠프 진행 기간에 맞춘 맞춤형 메시지를 보낸다.
  4. 댓글을 5개 이상 받는다.
  5. 🔥 하루 응답 수 또는 리액션 수를 로그로 기록해서 어느 메시지가 반응이 좋았는지 파악하여 업데이트를 진행해 본다.
  6. 🔥 매일 정해진 시간(오후 2시, 오후 6시 등)에 **자동화**하여 메시지를 전송한다.

1. slack 앱 생성

![image.png](attachment:cc5dfd23-9a7c-4853-ad48-cdfa8939d7a0:image.png)

https://api.slack.com/apps

1. `Create New App` > `From scratch` 클릭

**App Name 에 “캠프 토닥이” 입**

![image.png](attachment:fbcd0915-7196-4da0-8d12-f9115ee0edc4:image.png)

1. Features > App Home > **App Display Name `Edit`** 클릭

![image.png](attachment:354076e6-d87b-4003-9b16-252704c3842c:image.png)

1. Features > OAuth & Permissions > Scope

![image.png](attachment:9ca03b36-5b8d-48bd-af8a-24d4f2572abd:image.png)

```jsx
npm install @slack/bolt
```

### 리액션이 달리자마자 감지할 수 있도록 Socket Mode 활성화하는 방법

1. **"Socket Mode"** 탭 클릭 → **Enable Socket Mode**
2. Setting Basic Information 에서 **"App-level Tokens"** 클릭
3. **"Generate Token and Scopes"** 클릭
4. Token 이름 설정 (예: `socket-token`)
5. **Scope: `connections:write`** 선택
6. 토큰이 발급되면 **`xapp-...` 형태의 토큰 복사**

## **슬랙 Slash Command `/토닥`**

```

SLACK_SIGNING_SECRET=...
```

1. `/토닥` 명령어는 Slack App 설정 페이지에서 "Slash Commands"로 등록해야 합니다:

- **Command**: `/토닥`

![image.png](attachment:62fa96b5-eea2-4788-b8fc-2b9442851694:image.png)

```javascript
require("dotenv").config();
const axios = require("axios");
const fs = require("fs");
const cron = require("node-cron");
const { App } = require("@slack/bolt");
const express = require("express");
const bodyParser = require("body-parser");
const appServer = express();

const messages = [
  "오늘도 잘 해내고 있어요! 💪",
  "지금 이 순간도 성장 중입니다 🌱",
  "당신의 노력을 응원해요! 🙌",
  "쉬어가도 괜찮아요. 천천히 가도 돼요 🍀",
  "오늘 하루도 수고 많았어요 🌇",
];

// 🧠 감정 메시지 생성
const messagesByPhase = {
  early: [
    "새로운 시작! 여러분의 첫걸음을 응원해요 🚀",
    "처음은 언제나 설레죠! 잘 하고 있어요 😊",
  ],
  mid: [
    "지금이 가장 중요한 시기! 함께 버텨봐요 💪",
    "고비는 곧 기회! 조금만 더 힘내요 🔥",
  ],
  late: [
    "마무리가 가까워졌어요! 끝까지 응원할게요 🏁",
    "지금까지 잘 해온 것처럼, 마지막까지도 잘 할 거예요 ✨",
  ],
};

const timeMessages = {
  morning: [
    "좋은 아침이에요! 오늘도 힘내요 ☀️",
    "기분 좋은 하루의 시작, 함께 열어요 🌼",
  ],
  afternoon: [
    "점심 먹고 나른할 때, 잠깐 스트레칭 어떠세요? 🤸",
    "오늘 하루도 반 넘었어요! 남은 시간도 화이팅 💫",
  ],
  evening: ["오늘 하루도 수고 많았어요 🌙", "하루 마무리 잘하고 푹 쉬세요 😴"],
};

const weeklyMessages = {
  0: ["일요일은 충전하는 날! 푹 쉬어주세요 🔋"],
  1: ["월요일! 새로운 한 주도 파이팅입니다 🔥"],
  2: ["화요일엔 리듬을 타보세요! 🎵"],
  3: ["수요일, 벌써 절반 왔어요 🐫"],
  4: ["목요일은 주말이 보이기 시작하는 날 👀"],
  5: ["금요일이에요! 한 주 고생 많았어요 🎉"],
  6: ["주말 잘 보내고 있나요? 토닥토닥 🤗"],
};

// 캠프 주차 계산
function getCampWeek() {
  const startDate = new Date(process.env.CAMP_START_DATE || "2025-07-01");
  const now = new Date();
  const diffDays = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
  const week = Math.floor(diffDays / 7) + 1;
  return week < 1 ? 1 : week;
}

function getEncouragement(week) {
  if (week <= 2)
    return `지금은 캠프 ${week}주차! 아직은 적응 중이에요 💫\n잘하고 있어요, 처음이 제일 어렵죠!`;
  if (week <= 5)
    return `벌써 ${week}주차! 중반을 넘고 있어요 💪\n지금이 가장 중요한 시기, 조금만 더 힘내요!`;
  return `캠프 ${week}주차🎉 마지막 스퍼트 구간이에요!\n여기까지 온 당신이 자랑스러워요 👏`;
}

function getCampPhase() {
  const startDate = new Date("2025-07-01");
  const now = new Date();
  const diffDays = Math.floor((now - startDate) / (1000 * 60 * 60 * 24));
  const week = Math.floor(diffDays / 7) + 1;

  if (week <= 2) return "early";
  if (week <= 5) return "mid";
  return "late";
}

function getTimeOfDay(hour) {
  if (hour < 12) return "morning";
  if (hour < 18) return "afternoon";
  return "evening";
}

function getCustomMessage() {
  const now = new Date();
  const hour = now.getHours();
  const day = now.getDay(); // 0 = Sunday

  const time = getTimeOfDay(hour);
  const phase = getCampPhase();

  const timeMsg = timeMessages[time];
  const phaseMsg = messagesByPhase[phase];
  const weekMsg = weeklyMessages[day] || [];

  // 메시지 무작위로 섞기
  const allCandidates = [...timeMsg, ...phaseMsg, ...weekMsg];

  return allCandidates[Math.floor(Math.random() * allCandidates.length)];
}

// 📊 리액션/답글 통계 가져오기
async function fetchMessageStats(channel, ts, token) {
  try {
    const [reactionRes, repliesRes] = await Promise.all([
      axios.get("https://slack.com/api/reactions.get", {
        params: { channel, timestamp: ts },
        headers: { Authorization: `Bearer ${token}` },
      }),
      axios.get("https://slack.com/api/conversations.replies", {
        params: { channel, ts },
        headers: { Authorization: `Bearer ${token}` },
      }),
    ]);

    const reactionCount =
      reactionRes.data.message?.reactions?.reduce(
        (sum, r) => sum + r.count,
        0
      ) || 0;
    const replyCount = repliesRes.data?.messages?.length - 1 || 0;

    return { reactionCount, replyCount };
  } catch (err) {
    console.error("📛 Error fetching message stats:", err.message);
    return { reactionCount: 0, replyCount: 0 };
  }
}

function formatSummary(logs) {
  return logs
    .map((log, i) => {
      return `• ${i + 1}. "${log.text}"\n   🔁 ${
        log.reactions
      } reactions / 💬 ${log.replies} replies`;
    })
    .join("\n\n");
}

function getTodayLogs(allLogs) {
  const today = new Date().toISOString().slice(0, 10); // yyyy-mm-dd
  return allLogs.filter((log) => log.date.startsWith(today));
}

function getTopMessages(logs, topN = 3) {
  return logs
    .map((log) => ({
      ...log,
      score: log.reactions + log.replies,
    }))
    .sort((a, b) => b.score - a.score)
    .slice(0, topN);
}

async function sendSummaryToSlack() {
  const token = process.env.SLACK_TOKEN;
  const channel = process.env.CHANNEL_ID;

  const logs = fs.existsSync("reaction-log.json")
    ? JSON.parse(fs.readFileSync("reaction-log.json", "utf-8"))
    : [];

  const todayLogs = getTodayLogs(logs);
  const bestAllTime = getTopMessages(logs);
  const bestToday = getTopMessages(todayLogs);

  const bestText = `\n\n🏆 *역대 반응 좋은 메시지 TOP ${
    bestAllTime.length
  }*\n\n${formatSummary(bestAllTime)}`;

  // 슬랙 전송
  try {
    await axios.post(
      "https://slack.com/api/chat.postMessage",
      {
        channel,
        text: `${bestText}`,
      },
      {
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
      }
    );
    console.log("📤 Summary sent to Slack");

    // best-messages.json 저장
    fs.writeFileSync(
      "best-messages.json",
      JSON.stringify(bestAllTime, null, 2)
    );
    console.log("✅ Best messages saved");
  } catch (err) {
    console.error("📛 Failed to send summary:", err.message);
  }
}

// 📩 슬랙 메시지 전송 및 반응 통계 저장
async function sendSlackMessage() {
  const token = process.env.SLACK_TOKEN;
  const channel = process.env.CHANNEL_ID;
  const text = getCustomMessage();

  try {
    const res = await axios.post(
      "https://slack.com/api/chat.postMessage",
      { channel, text },
      {
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
      }
    );

    const ts = res.data.ts;
    console.log(`[${new Date().toISOString()}] Sent message: ${text}`);

    if (ts) {
      // 10초 후에 반응 통계를 가져옴
      setTimeout(async () => {
        const stats = await fetchMessageStats(channel, ts, token);

        const logEntry = {
          date: new Date().toISOString(),
          text,
          reactions: stats.reactionCount,
          replies: stats.replyCount,
        };

        const existingLogs = fs.existsSync("reaction-log.json")
          ? JSON.parse(fs.readFileSync("reaction-log.json", "utf-8"))
          : [];

        existingLogs.push(logEntry);
        fs.writeFileSync(
          "reaction-log.json",
          JSON.stringify(existingLogs, null, 2)
        );

        console.log("✅ Reaction stats saved:", logEntry);
      }, 10000);
    }
  } catch (err) {
    console.error("📛 Message sending failed:", err.message);
  }
}

// 🕒 매일 14시, 18시에 실행
cron.schedule("0 12,13,18,22 * * *", sendSlackMessage);

// 매일 오후 9시에 요약 보고 전송
cron.schedule("0 21 * * *", sendSummaryToSlack);

// 📦 앱 실행 시 즉시 1회 실행
// sendSlackMessage();
// sendSummaryToSlack();

// ===============================
// ⚡ 리액션 실시간 감지 (Socket Mode)
// ===============================
const app = new App({
  token: process.env.SLACK_TOKEN, // Bot User OAuth Token
  appToken: process.env.SLACK_APP_TOKEN, // App-level Token (xapp-...)
  signingSecret: process.env.SLACK_SIGNING_SECRET,
  socketMode: true,
});

// 👀 리액션 이벤트 감지
app.event("reaction_added", async ({ event, client }) => {
  try {
    const { channel, ts } = event.item;

    // 메시지 가져오기
    const result = await client.conversations.history({
      channel,
      latest: ts,
      inclusive: true,
      limit: 1,
    });

    const message = result.messages[0];

    const logEntry = {
      date: new Date().toISOString(),
      text: message.text,
      user: event.user,
      reaction: event.reaction,
      ts,
    };

    const existing = fs.existsSync("reaction-events.json")
      ? JSON.parse(fs.readFileSync("reaction-events.json", "utf-8"))
      : [];

    existing.push(logEntry);
    fs.writeFileSync("reaction-events.json", JSON.stringify(existing, null, 2));

    console.log("💬 리액션 감지됨:", logEntry);
  } catch (err) {
    console.error("❌ 리액션 감지 에러:", err.message);
  }
});

// 🔹 `/토닥` 명령어 핸들링
app.command("/토닥", async ({ command, ack, respond }) => {
  await ack();

  const week = getCampWeek();
  const msg = getEncouragement(week);

  await respond({
    text: `안녕하세요 <@${command.user_id}>님! 🧸\n${msg}`,
    response_type: "in_channel", // 채널에 공개
  });
});

// 🟢 Socket Mode 앱 실행
(async () => {
  await app.start();
  console.log("⚡ Socket Mode 슬랙 앱 실행 중");
})();
```

### 느낀점

아이디어를 직접 코드로 구현하고, 그 결과물인 봇이 우리 릴레이 프로젝트 팀 채널에서 실제로 작동하는 것을 보니까 재밌었습니. 처음에는 막연하게 상상했던 기능들이 쉽게 코드로 작성되고 사용하는 모습을 보니 뿌듯했습니다. 이후에도 새로운 기능을 추가하고 기존에 있는 기능일 개선해나가고 싶다는 생각이 들었습니다.
